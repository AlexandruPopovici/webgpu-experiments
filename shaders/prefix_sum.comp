#version 450 core

// See https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf

layout(local_size_x = BLOCK_SIZE / 2) in;

layout(set = 0, binding = 0, std430) buffer Data {
    uint vals[];
};

layout(set = 0, binding = 1, std430) buffer BlockSums {
    uint block_sums[];
};

shared uint chunk[BLOCK_SIZE];

void main(void) {
#if SERIAL_KERNELS
    if (gl_LocalInvocationID.x == 0) {
        for (int i = 0; i < BLOCK_SIZE; ++i) {
            chunk[i] = vals[2 * gl_GlobalInvocationID.x + i];
        }

        uint offs = 1;
        // Reduce step up tree
        for (int d = BLOCK_SIZE >> 1; d > 0; d = d >> 1) {
            for (int t = 0; t < d; ++t) {
                uint a = offs * (2 * t + 1) - 1;
                uint b = offs * (2 * t + 2) - 1;
                chunk[b] += chunk[a];
            }
            offs = offs << 1;
        }

        block_sums[gl_WorkGroupID.x] = chunk[BLOCK_SIZE - 1];
        chunk[BLOCK_SIZE - 1] = 0;

        // Sweep down the tree to finish the scan
        for (int d = 1; d < BLOCK_SIZE; d = d << 1) {
            offs = offs >> 1;
            for (int t = 0; t < d; ++t) {
                uint a = offs * (2 * t + 1) - 1;
                uint b = offs * (2 * t + 2) - 1;
                const uint tmp = chunk[a];
                chunk[a] = chunk[b];
                chunk[b] += tmp;
            }
        }

        for (int i = 0; i < BLOCK_SIZE; ++i) {
            vals[2 * gl_GlobalInvocationID.x + i] = chunk[i];
        }
    }
#else
    chunk[2 * gl_LocalInvocationID.x] = vals[2 * gl_GlobalInvocationID.x];
    chunk[2 * gl_LocalInvocationID.x + 1] = vals[2 * gl_GlobalInvocationID.x + 1];

    uint offs = 1;
    // Reduce step up tree
    for (int d = BLOCK_SIZE >> 1; d > 0; d = d >> 1) {
        // TODO: Having memory barriers work (i.e., work groups > warp size) requires the
        // WebGPU subgroup support extension
        memoryBarrierShared();
        if (gl_LocalInvocationID.x < d) {
            uint a = offs * (2 * gl_LocalInvocationID.x + 1) - 1;
            uint b = offs * (2 * gl_LocalInvocationID.x + 2) - 1;
            chunk[b] += chunk[a];
        }
        offs = offs << 1;
    }

    if (gl_LocalInvocationID.x == 0) {
        block_sums[gl_WorkGroupID.x] = chunk[BLOCK_SIZE - 1];
        chunk[BLOCK_SIZE - 1] = 0;
    }

    // Sweep down the tree to finish the scan
    for (int d = 1; d < BLOCK_SIZE; d = d << 1) {
        offs = offs >> 1;
        memoryBarrierShared();
        if (gl_LocalInvocationID.x < d) {
            uint a = offs * (2 * gl_LocalInvocationID.x + 1) - 1;
            uint b = offs * (2 * gl_LocalInvocationID.x + 2) - 1;
            const uint tmp = chunk[a];
            chunk[a] = chunk[b];
            chunk[b] += tmp;
        }
    }

    memoryBarrierShared();
    vals[2 * gl_GlobalInvocationID.x] = chunk[2 * gl_LocalInvocationID.x];
    vals[2 * gl_GlobalInvocationID.x + 1] = chunk[2 * gl_LocalInvocationID.x + 1];
#endif
}

